<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Spotify Player</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        background: #121212;
        color: white;
      }
      .track-container {
        background: #282828;
        padding: 20px;
        border-radius: 8px;
        margin: 10px 0;
      }
      .track-info {
        display: flex;
        align-items: center;
        gap: 15px;
      }
      .track-image {
        width: 64px;
        height: 64px;
        border-radius: 4px;
      }
      .queue-title {
        color: #1db954;
        margin-top: 30px;
      }
      button {
        background: #1db954;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 20px;
        cursor: pointer;
        margin: 20px 0;
      }
      button:hover {
        background: #1ed760;
      }
    </style>
  </head>
  <body>
    <h1>Spotify Player</h1>
    <button id="authorize">Connect to Spotify</button>

    <div id="player-container" style="display: none">
      <h2>Now Playing</h2>
      <div id="current-track" class="track-container"></div>

      <h2 class="queue-title">Coming Up Next.</h2>
      <div id="queue-container"></div>
    </div>

    <script>
      const clientId = "7327a7e644944f329380d56e46f30201"; // Replace with your Spotify Client ID
      const redirectUri = "http://localhost:5500"; // Replace with your redirect URI
      const scope = "user-read-currently-playing user-read-playback-state";

      // Function to generate a random string for state
      function generateRandomString(length) {
        const possible =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        const values = crypto.getRandomValues(new Uint8Array(length));
        return values.reduce(
          (acc, x) => acc + possible[x % possible.length],
          ""
        );
      }

      // Function to handle authorization
      document.getElementById("authorize").addEventListener("click", () => {
        const state = generateRandomString(16);
        const authUrl = new URL("https://accounts.spotify.com/authorize");

        authUrl.searchParams.append("client_id", clientId);
        authUrl.searchParams.append("response_type", "token");
        authUrl.searchParams.append("redirect_uri", redirectUri);
        authUrl.searchParams.append("scope", scope);
        authUrl.searchParams.append("state", state);

        window.location.href = authUrl.toString();
      });

      // Function to get access token from URL hash
      function getAccessToken() {
        const hash = window.location.hash
          .substring(1)
          .split("&")
          .reduce((acc, item) => {
            const parts = item.split("=");
            acc[parts[0]] = decodeURIComponent(parts[1]);
            return acc;
          }, {});

        return hash.access_token;
      }

      // Function to fetch currently playing track
      async function getCurrentlyPlaying(accessToken) {
        try {
          const response = await fetch(
            "https://api.spotify.com/v1/me/player/currently-playing",
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            }
          );

          if (response.status === 204) {
            return null; // No track currently playing
          }

          return await response.json();
        } catch (error) {
          console.error("Error fetching current track:", error);
          return null;
        }
      }

      // Function to fetch queue
      async function getQueue(accessToken) {
        try {
          const response = await fetch(
            "https://api.spotify.com/v1/me/player/queue",
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            }
          );
          return await response.json();
        } catch (error) {
          console.error("Error fetching queue:", error);
          return null;
        }
      }

      // Function to display track information
      function displayTrack(trackData, container) {
        if (!trackData) {
          container.innerHTML = "<p>No track information available</p>";
          return;
        }

        const track = trackData.item || trackData;
        const artistNames = track.artists
          .map((artist) => artist.name)
          .join(", ");
        const albumImage = track.album.images[0]?.url;

        container.innerHTML = `
                <div class="track-info">
                    ${
                      albumImage
                        ? `<img src="${albumImage}" alt="Album art" class="track-image">`
                        : ""
                    }
                    <div>
                        <h3>${track.name}</h3>
                        <p>${artistNames}</p>
                        <p>${track.album.name}</p>
                    </div>
                </div>
            `;
      }

      // Function to update player information
      async function updatePlayerInfo(accessToken) {
        const currentTrack = await getCurrentlyPlaying(accessToken);
        const queue = await getQueue(accessToken);

        const currentTrackContainer = document.getElementById("current-track");
        const queueContainer = document.getElementById("queue-container");

        // Display current track
        if (currentTrack) {
          displayTrack(currentTrack, currentTrackContainer);
        } else {
          currentTrackContainer.innerHTML = "<p>No track currently playing</p>";
        }

        // Display queue
        if (queue && queue.queue) {
          queueContainer.innerHTML = "";
          queue.queue.slice(0, 5).forEach((track) => {
            const trackElement = document.createElement("div");
            trackElement.className = "track-container";
            displayTrack(track, trackElement);
            queueContainer.appendChild(trackElement);
          });
        } else {
          queueContainer.innerHTML = "<p>No tracks in queue</p>";
        }
      }

      // Check if we have an access token and initialize the player
      window.onload = () => {
        const accessToken = getAccessToken();
        if (accessToken) {
          document.getElementById("authorize").style.display = "none";
          document.getElementById("player-container").style.display = "block";

          // Update player info immediately and every 5 seconds
          updatePlayerInfo(accessToken);
          setInterval(() => updatePlayerInfo(accessToken), 5000);
        }
      };
    </script>
  </body>
</html>
